MODULE GenerateComparer;

-- Create a valid C# name
PROCEDURE ValidName ( name )
BEGIN
  RESULT := name;
  RESULT := STR.Replace ( RESULT, "-", "_" );
  RESULT := STR.Replace ( RESULT, "/", "_" );
  RESULT := STR.Replace ( RESULT, ".", "_" );
  RESULT := STR.Replace ( RESULT, " ", "_" );
END ValidName;

-- Generates the class for the corresponding element
PROCEDURE GenerateImporterClass ( doc )
BEGIN
  FILE1.Redirect ("src/Comparer.cs");
  FILE1.WriteList ({
`// ------------------------------------------------------------------------------
`// -- Copyright ERTMS Solutions
`// -- Licensed under the EUPL V.1.1
`// -- http://joinup.ec.europa.eu/software/page/eupl/licence-eupl
`// --
`// -- This file is part of ERTMSFormalSpec software and documentation
`// --
`// --  ERTMSFormalSpec is free software: you can redistribute it and/or modify
`// --  it under the terms of the EUPL General Public License, v.1.1
`// --
`// -- ERTMSFormalSpec is distributed in the hope that it will be useful,
`// -- but WITHOUT ANY WARRANTY; without even the implied warranty of
`// -- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
`// --
`// ------------------------------------------------------------------------------
`
`namespace DataDictionary
`{
`    /// <summary>
`    /// This class is used to compare two dictionaries 
`    /// by annotating the first dictionary with the differences with the second
`    /// </summary>
`    public static class Comparer
`    {
`
`        /// <summary>
`        /// Computes a canonic form of a string
`        /// </summary>
`        /// <param name="s1"></param>
`        /// <returns></returns>
`        public static string canonicString(string s1)
`        {
`            string retVal = s1;
`
`            if (retVal == null)
`            {
`                retVal = "";
`            }
`
`            retVal = retVal.Replace('\n', ' ');
`            retVal = retVal.Replace('\t', ' ');
`            retVal = retVal.Replace('\r', ' ');
`
`            while (retVal.IndexOf("  ") >= 0)
`            {
`                retVal = retVal.Replace("  ", " ");
`            }
`
`            return retVal;
`        }
`
`        /// <summary>
`        /// Compares two strings
`        /// </summary>
`        /// <param name="s1"></param>
`        /// <param name="s2"></param>
`        /// <returns></returns>
`        public static bool canonicalStringEquality(string s1, string s2)
`        {
`            bool retVal;
`
`            s1 = canonicString(s1);
`            s2 = canonicString(s2);
`            retVal = s1 == s2;
`
`            return retVal;
`        }
`
  });

  FOR element IN doc.RecursiveGetElementChildNodes("ELEMENT") DO  

    IF InheritsFrom(element, "ModelElement") THEN
      FILE1.WriteList ({
`        /// <summary>
`        /// Compares two `element.NAME` and annotates the differences on the first one
`        /// </summary>
`        /// <param name="obj"></param>
`        /// <param name="other"></param>
`        public static void compare`ValidName (element.NAME)`(Generated.`ValidName (element.NAME)` obj, Generated.`ValidName (element.NAME)` other)
`        {
`            if ( other == null )
`            { 
`                obj.AddInfo ("Element has been added");
`                return;
`            }
`
      });

      IF ( element CAN BaseElement ) AND InheritsFrom(element.BaseElement,"ModelElement") THEN
      FILE1.WriteList ({
`            compare`ValidName (element.BaseElement.NAME)` (obj, other);
`
      });
      END;

      FOR field IN element.RecursiveGetElementChildNodes ("FIELD") DO
        IF ( field CAN TYPE ) OR ( field CAN ENUMTYPE ) THEN
          IF ( field!TYPE = "STRING" OR field!TYPE = "PCHAR" ) THEN
            FILE1.WriteList ({
`            if ( !canonicalStringEquality(obj.get`ValidName(field.NAME)`(), other.get`ValidName(field.NAME)`()) )
`            {
`                obj.AddInfo ("Value of `field.NAME` changed. Previous value was " + other.get`field.NAME`());
`            }
            });
          ELSE
            FILE1.WriteList ({
`            if ( obj.get`ValidName(field.NAME)`() != other.get`ValidName(field.NAME)`() )
`            {
`                obj.AddInfo ("Value of `field.NAME` changed. Previous value was " + other.get`field.NAME`());
`            }
            });
          END;
        ELSIF ( field CAN REFTYPE ) AND (InheritsFrom(Elements[field.REFTYPE],"ModelElement"))THEN          
          IF ( THERE_IS IN element.RecursiveGetElementChildNodes ("REPEAT") :- X.TARGET == field.NAME ) THEN
            FILE1.WriteList({
`            if ( obj.all`field.NAME`() != null && other.all`field.NAME`() != null ) 
`            {
`                foreach ( Generated.`field.REFTYPE` subElement in obj.all`field.NAME`() )
`                {
`                    bool compared = false;
`                    foreach ( Generated.`field.REFTYPE` otherElement in other.all`field.NAME`() )
`                    {
`                        if ( canonicalStringEquality(subElement.Name, otherElement.Name) )
`                        {
`                            compare`ValidName (field.REFTYPE)` ( subElement, otherElement );
`                            compared = true;
`                            break;
`                        }
`                    }
`
`                    if ( !compared ) 
`                    {
`                        subElement.AddInfo ("Element added");
`                    }
`                }
``
`                foreach ( Generated.`field.REFTYPE` otherElement in other.all`field.NAME`() )
`                {
`                    bool found = false;
`                    foreach ( Generated.`field.REFTYPE` subElement in obj.all`field.NAME`() )
`                    {
`                        if ( canonicalStringEquality(subElement.Name, otherElement.Name) )
`                        {
`                            found = true;
`                            break;
`                        }
`                   }
`
`                   if ( !found )
`                   {
`                      obj.AddInfo("Element " + otherElement.Name + " has been removed");                   
`                   }
`               }
`            }
            });
          ELSE
            FILE1.WriteList({
`            if ( obj.get`field.NAME`() == null )
`            {
`                if ( other.get`field.NAME`() != null )
`                {
`                    obj.AddInfo ("Element `field.NAME` has been removed");
`                }
`            }
`            else
`            {
`                compare`ValidName (field.REFTYPE)` ( obj.get`field.NAME`(), other.get`field.NAME`() );
`            }
            });
          END; -- IF
        END; -- IF
      END; -- FOR field
      FILE1.WriteList ({
`        }
`
      });
    END; -- FOR element
  END; -- IF

  FILE1.WriteList ({
`    }
`}
  });
  FILE1.Flush;
END GenerateImporterClass;

VAR
  Elements;

-- Creates the symbol table for the elements of the system
PROCEDURE PopulateSymbols( doc )
BEGIN
  Elements := ASSOC.New;
  FOR IN doc.RecursiveGetElementChildNodes("ELEMENT") DO
    Elements[X.NAME] := X;
  END;
END PopulateSymbols;

PROCEDURE CreateClassHierarchy ( doc )
BEGIN
  FOR IN doc.RecursiveGetElementChildNodes("ELEMENT") DO
    IF X CAN BASEELEMENT THEN
      X.BaseElement := Elements[X.BASEELEMENT];
    END;
  END;
END;

PROCEDURE InheritsFrom(Element, BaseElement)
VAR 
  current;
BEGIN
  RESULT := FALSE;
  current := Element;
  WHILE ( current <> VOID ) AND NOT RESULT DO
--    OUT.WriteLn (' -- ' & current.NAME &' '& current!BASECLASS &' =?= '& BaseElement &' -> '& RESULT);
    RESULT := current!BASECLASS == BaseElement;
    current := current!BaseElement;
  END;
END;

PROCEDURE TERMINATE;
VAR 
  doc;
BEGIN
  OUT.WriteLn ("Starting process");
  doc := XML.LoadFile ( SYS.Args[1] );
  OUT.WriteLn ("XML document read");
  IF doc <> VOID THEN
    doc := doc.GetDocumentElement;

    OUT.WriteLn ("Populate symbols");
    PopulateSymbols( doc );

    OUT.WriteLn ("Create class hierarchy");
    CreateClassHierarchy ( doc );

    OUT.WriteLn ("Generate comparer class");
    GenerateImporterClass ( doc );
    
  ELSE
    ERR.WriteLn ( "Cannot read file " & SYS.Args[1] );
  END;

  OUT.WriteLn ("Done");
END TERMINATE;

